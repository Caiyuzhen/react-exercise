{"ast":null,"code":"var _jsxFileName = \"/Users/zen/Desktop/react-exercise/src/App.js\",\n    _s = $RefreshSig$();\n\nimport \"./App.css\";\nimport React from 'react'; //1.从 react 中导入 useState 函数\n\nimport { useState } from 'react'; //🚀 Hooks\n// Why？\n//总结来说，解决两个问题：\n//1.组件的状态逻辑复用 🌟\n//2.class 自身的问题，class 很复杂\n//What？\n//Hook 的本质是一套能使【函数组件】具备更强大更灵活的“钩子函数（在某个时机下自动执行）”\n//函数组件更加契合 React 的设计理念，比如 `UI = fn(data)`,缺点则是函数组件没有自己的状态，于是出现了 Hook，Hook 是为了让函数组件拥有自己的状态\n//只能在函数组件中使用 🌟\n//有什么优势？\n//1.解决业务逻辑难以拆分的问题\n//2.使状态的逻辑复用变得简单可行\n//3.更加契合 React 的理念: `UI = fn(data)`\n//How?\n//使用步骤 🌟\n//1.从 react 中导入 useState 函数\n//2.执行 useState 函数并传入初始值（初始值必须在函数组件中）\n//3.从函数的执行结果中解构出 [数据，修改数据的方法]\n//4.使用数据、修改数据\n//——————————————————————————————————————————————————————————————————\n\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nfunction App() {\n  _s();\n\n  const [count, setCount] = useState(0); //2.执行 useState 函数并传入初始值（初始值必须在函数组件中）  3.从函数的执行结果中解构出 [数据，修改数据的方法]\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: () => setCount(count + 1),\n      children: [\"\\u70B9\\u51FB +\", \" \"]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 36,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 35,\n    columnNumber: 5\n  }, this);\n} // //最后需要 export 一下！\n\n\n_s(App, \"RpyMek13f3iNeQO0Gs9DEYmHKoY=\");\n\n_c = App;\nexport default App;\n\nvar _c;\n\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["React","useState","App","count","setCount"],"sources":["/Users/zen/Desktop/react-exercise/src/App.js"],"sourcesContent":["import \"./App.css\"\nimport React from 'react' \n//1.从 react 中导入 useState 函数\nimport {useState} from 'react'\n\n\n//🚀 Hooks\n    // Why？\n      //总结来说，解决两个问题：\n        //1.组件的状态逻辑复用 🌟\n        //2.class 自身的问题，class 很复杂\n    \n    //What？\n      //Hook 的本质是一套能使【函数组件】具备更强大更灵活的“钩子函数（在某个时机下自动执行）”\n      //函数组件更加契合 React 的设计理念，比如 `UI = fn(data)`,缺点则是函数组件没有自己的状态，于是出现了 Hook，Hook 是为了让函数组件拥有自己的状态\n      //只能在函数组件中使用 🌟\n      //有什么优势？\n        //1.解决业务逻辑难以拆分的问题\n        //2.使状态的逻辑复用变得简单可行\n        //3.更加契合 React 的理念: `UI = fn(data)`\n    \n    //How?\n      //使用步骤 🌟\n        //1.从 react 中导入 useState 函数\n        //2.执行 useState 函数并传入初始值（初始值必须在函数组件中）\n        //3.从函数的执行结果中解构出 [数据，修改数据的方法]\n        //4.使用数据、修改数据\n\n\n//——————————————————————————————————————————————————————————————————\n\nfunction App() {\n  const [count,setCount] = useState(0)//2.执行 useState 函数并传入初始值（初始值必须在函数组件中）  3.从函数的执行结果中解构出 [数据，修改数据的方法]\n  return(\n    <div>\n      <button\n        onClick={() => setCount(count+1)}\n      >点击 +{} </button>\n    </div>\n  )\n}\n\n\n\n\n// //最后需要 export 一下！\nexport default App\n\n\n"],"mappings":";;;AAAA,OAAO,WAAP;AACA,OAAOA,KAAP,MAAkB,OAAlB,C,CACA;;AACA,SAAQC,QAAR,QAAuB,OAAvB,C,CAGA;AACI;AACE;AACE;AACA;AAEJ;AACE;AACA;AACA;AACA;AACE;AACA;AACA;AAEJ;AACE;AACE;AACA;AACA;AACA;AAGR;;;;AAEA,SAASC,GAAT,GAAe;EAAA;;EACb,MAAM,CAACC,KAAD,EAAOC,QAAP,IAAmBH,QAAQ,CAAC,CAAD,CAAjC,CADa,CACuB;;EACpC,oBACE;IAAA,uBACE;MACE,OAAO,EAAE,MAAMG,QAAQ,CAACD,KAAK,GAAC,CAAP,CADzB;MAAA;IAAA;MAAA;MAAA;MAAA;IAAA;EADF;IAAA;IAAA;IAAA;EAAA,QADF;AAOD,C,CAKD;;;GAdSD,G;;KAAAA,G;AAeT,eAAeA,GAAf"},"metadata":{},"sourceType":"module"}