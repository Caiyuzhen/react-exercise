{"ast":null,"code":"var _jsxFileName = \"/Users/zen/Desktop/react-exercise/src/App.js\",\n    _s = $RefreshSig$();\n\nimport \"./App.css\";\nimport React from 'react'; //1.从 react 中导入 useState 函数\n\nimport { useState } from 'react'; //🚀 Hooks\n// Why？\n//总结来说，解决两个问题：\n//1.组件的状态逻辑复用 🌟\n//2.class 自身的问题，class 很复杂\n//What？\n//本质是什么？\n//Hook 的本质是一套能使【函数组件】具备更强大更灵活的“钩子函数（在某个时机下自动执行）”\n//注意事项\n//只能在函数组件中使用 🌟\n//有什么优势？\n//1.解决业务逻辑难以拆分的问题\n//2.使状态的逻辑复用变得简单可行\n//3.更加契合 React 的设计理念: `UI = fn(data)`, 起因是函数组件没有自己的状态，于是出现了 Hook，Hook 是为了让函数组件拥有自己的状态\n//有哪些 hook 函数？\n//🔥 useState 函数\n//const [count,setCount] = useState(x)\n//count 名字可以自定义，setCount 名字可以自定义， x 为初始值, 顺序不能换，前一个是【数据状态值】，后一个是【修改数据的函数】\n//🌟🌟数组的解构赋值是有顺序的，对象的解构赋值是无顺序的🔥🔥\n//setCount 不是修改原值，而是【🔥🔥生成一个新值来替换原值】\n//How?\n//使用步骤 🌟\n//1.从 react 中导入 useState 函数\n//2.执行 useState 函数并传入初始值（初始值必须在函数组件中）\n//3.从函数的执行结果中解构出 【数据状态值，修改数据的方法】\n//4.使用数据、修改数据\n//——————————————————————————————————————————————————————————————————\n\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nfunction App() {\n  _s();\n\n  //👇相当于从【setState的数组中】解构出【数字、方法】\n  const [count, setCount] = useState(0); //2.执行 useState 函数并传入初始值（初始值必须在函数组件中）  3.从函数的执行结果中解构出 [数据，修改数据的方法]\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: () => setCount(count + 1),\n      children: [\" \\u70B9\\u51FB + \", count, \"  \"]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 53,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 52,\n    columnNumber: 5\n  }, this);\n} // //最后需要 export 一下！\n\n\n_s(App, \"RpyMek13f3iNeQO0Gs9DEYmHKoY=\");\n\n_c = App;\nexport default App;\n\nvar _c;\n\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["React","useState","App","count","setCount"],"sources":["/Users/zen/Desktop/react-exercise/src/App.js"],"sourcesContent":["import \"./App.css\"\nimport React from 'react' \n//1.从 react 中导入 useState 函数\nimport {useState} from 'react'\n\n\n//🚀 Hooks\n    // Why？\n      //总结来说，解决两个问题：\n        //1.组件的状态逻辑复用 🌟\n        //2.class 自身的问题，class 很复杂\n    \n\n\n    //What？\n      //本质是什么？\n        //Hook 的本质是一套能使【函数组件】具备更强大更灵活的“钩子函数（在某个时机下自动执行）”\n\n      //注意事项\n        //只能在函数组件中使用 🌟\n\n      //有什么优势？\n        //1.解决业务逻辑难以拆分的问题\n        //2.使状态的逻辑复用变得简单可行\n        //3.更加契合 React 的设计理念: `UI = fn(data)`, 起因是函数组件没有自己的状态，于是出现了 Hook，Hook 是为了让函数组件拥有自己的状态\n      \n      //有哪些 hook 函数？\n        //🔥 useState 函数\n            //const [count,setCount] = useState(x)\n            //count 名字可以自定义，setCount 名字可以自定义， x 为初始值, 顺序不能换，前一个是【数据状态值】，后一个是【修改数据的函数】\n            //🌟🌟数组的解构赋值是有顺序的，对象的解构赋值是无顺序的🔥🔥\n            //setCount 不是修改原值，而是【🔥🔥生成一个新值来替换原值】\n\n    \n\n    //How?\n      //使用步骤 🌟\n        //1.从 react 中导入 useState 函数\n        //2.执行 useState 函数并传入初始值（初始值必须在函数组件中）\n        //3.从函数的执行结果中解构出 【数据状态值，修改数据的方法】\n        //4.使用数据、修改数据\n\n\n//——————————————————————————————————————————————————————————————————\n\n\nfunction App() {\n  //👇相当于从【setState的数组中】解构出【数字、方法】\n  const [count,setCount] = useState(0)//2.执行 useState 函数并传入初始值（初始值必须在函数组件中）  3.从函数的执行结果中解构出 [数据，修改数据的方法]\n\n  return(\n    <div>\n      <button onClick = {() => setCount(count+1)}> 点击 + {count}  </button>\n    </div>\n  )\n}\n\n\n\n\n// //最后需要 export 一下！\nexport default App\n\n\n"],"mappings":";;;AAAA,OAAO,WAAP;AACA,OAAOA,KAAP,MAAkB,OAAlB,C,CACA;;AACA,SAAQC,QAAR,QAAuB,OAAvB,C,CAGA;AACI;AACE;AACE;AACA;AAIJ;AACE;AACE;AAEF;AACE;AAEF;AACE;AACA;AACA;AAEF;AACE;AACI;AACA;AACA;AACA;AAIR;AACE;AACE;AACA;AACA;AACA;AAGR;;;;AAGA,SAASC,GAAT,GAAe;EAAA;;EACb;EACA,MAAM,CAACC,KAAD,EAAOC,QAAP,IAAmBH,QAAQ,CAAC,CAAD,CAAjC,CAFa,CAEuB;;EAEpC,oBACE;IAAA,uBACE;MAAQ,OAAO,EAAI,MAAMG,QAAQ,CAACD,KAAK,GAAC,CAAP,CAAjC;MAAA,+BAAmDA,KAAnD;IAAA;MAAA;MAAA;MAAA;IAAA;EADF;IAAA;IAAA;IAAA;EAAA,QADF;AAKD,C,CAKD;;;GAdSD,G;;KAAAA,G;AAeT,eAAeA,GAAf"},"metadata":{},"sourceType":"module"}